\renewcommand*\chappic{img/satisfiability.pdf}
\renewcommand*\chapquote{What idiot called them logic errors rather than bool shit?}
\renewcommand*\chapquotesrc{Unknown}
\chapter{Satisfiability}
\label{ch:sat}
\vspace{50pt}
%\begin{center}
%  \def\svgwidth{100pt}
%  \import*{img/}{satisfiability.pdf_tex}
%\end{center}

\section{Preliminaries Redux}
\section{Satisfiability}
\label{sec:intro-sat}
%
\index{Boolean function}
\begin{defi}
  A \emph{Boolean function} is a mapping $h: X \to Y$ with $X = \left\{0,1\right\}^n$
  for $n \in \mathbb N_{\geq 1}$ and $Y = \left\{0,1\right\}$.
\end{defi}

The following definition gives three basic Boolean functions:

\index{AND (Boolean function)}
\index{OR (Boolean function)}
\index{NOT (Boolean function)}
\begin{defi}
  Let \boolf{AND}, \boolf{OR} and \boolf{NOT} be three Boolean functions.
  \begin{itemize}[noitemsep,topsep=0pt]
    \item
      \boolf{AND} maps $X = \left\{0,1\right\}^2$
      to $1$ if all values of $X$ are $1$.
    \item
      \boolf{OR} maps $X = \left\{0,1\right\}^2$
      to $1$ if any value of $X$ is $1$.
    \item
      \boolf{NOT} maps $X = \left\{0,1\right\}^1$
      to $1$ if the single value of $X$ is $0$.
  \end{itemize}
  All functions return $0$ in the other case.
\end{defi}

\index{Truth table}
\begin{defi}
  A \emph{truth table} unambiguously defines a Boolean function
  by enlisting the evaluated truth value for all possible sets of
  inputs.

  Table~\ref{tab:andornot-truthtables} shows truth tables for
  \boolf{AND}, \boolf{OR} and \boolf{NOT}.
\end{defi}

\begin{table}[pt]
  \centering
  \subfloat[\boolf{AND}]{%
    \begin{tabular}{cc|c}
      $v_1$ & $v_2$ & $f(v_1, v_2)$ \\
     \hline
      $1$ & $1$ & $1$ \\
      $1$ & $0$ & $0$ \\
      $0$ & $1$ & $0$ \\
      $0$ & $0$ & $0$
    \end{tabular}
  }
  ~
  \subfloat[\boolf{OR}]{%
    \begin{tabular}{cc|c}
      $v_1$ & $v_2$ & $f(v_1, v_2)$ \\
     \hline
      $1$ & $1$ & $1$ \\
      $1$ & $0$ & $1$ \\
      $0$ & $1$ & $1$ \\
      $0$ & $0$ & $0$
    \end{tabular}
  }
  ~
  \raisebox{13.6pt}{%
    \subfloat[\boolf{NOT}]{%
      \begin{tabular}{c|c}
        $v$ & $f(v)$ \\
       \hline
        $1$ & $0$ \\
        $0$ & $1$
      \end{tabular}
    }%
  }%
  \caption{Truth tables for \boolf{AND}, \boolf{OR} and \boolf{NOT}}
  \label{tab:andornot-truthtables}
\end{table}

Boolean functions have an important property which is characterized
in the following definition:

\index{Satisfiability}
\index{Assignment}
\index{Model}
\begin{defi}
  A Boolean function $f$ is \emph{satisfiable} iff there exists at least one
  input $x \in X$ such that $f(x) = 1$.
  Every input $x \in X$ satisfying this property is called \emph{model}.
  Every element of $X$ is called \emph{assignment}.
\end{defi}

The generic complexity of SAT determination is given by $2^n$ for $n$ Boolean variables.
%This is closely related to the \cP $\overset{?}{\neq}$ \cNP question.
The corresponding tool to determine satisfiability is defined as follows:

\index{SAT solver}
\begin{defi}
  A \emph{SAT solver} is a tool to determine satisfiability of a Boolean function.
  If satisfiability is given, it returns some model.
\end{defi}

SAT research is heavily concerned with finding good heuristics to find some model
for a given SAT problem as fast as possible. Biyearly
\href{http://satcompetition.org/}{SAT competitions} take place to challenge
SAT solvers in a set of benchmarks. The committee evaluates the most successful
SAT solvers solving the most problems within a given time frame.

\section{Satisfiability of hash algorithm states}
\label{sec:intro-algo-sat}
%
We discussed Boolean functions and satisfiability. At the same time we looked
at basic properties of hash algorithms. But the question remains how we can
link those areas together? This section is dedicated to this question.

\index{Algorithm}
\index{I/O Algorithm}
\begin{defi}
  An \emph{algorithm} is a step-wise set of instructions to solve a problem.
  An \emph{I/O algorithm} transforms given input values to output values.
\end{defi}

Hash algorithms are one example of I/O algorithms.

I/O algorithms can be implemented as a sequence of instructions for computers.
At the same time I/O algorithms can be represented as combination of Boolean
functions. This claim is backed in more detail in Section~\ref{sec:sat-dimacs}
with Theorem~\ref{thm:all-cnf}. It follows immediately that we can represent
I/O algorithms such as hash algorithms entirely as Boolean function.

\begin{theorem}
  Every algorithm can be represented as Boolean function.
\end{theorem}

\index{Least significant bit}
\index{Most significant bit}
We consider 2bit addition as small example. Let $a_{i}$ be the first argument
where $i$ denotes the binary position. If $i=0$, the \emph{least significant bit}
(LSB) is considered. If $i=1$, the \emph{most significant bit} (MSB) is considered.

Let $b_{i}$ be the second argument and $s_{i}$ be the output value.
Furthermore $c_{i}$ is the carry bit, where $c_1$ is left out, because
it is not used in 2bit addition. This model of 2bit addition as Boolean
function can be seen in Figure~\ref{fig:intro-2bit-addition}.

\begin{figure}
  \begin{center}
    \begin{tabular}{lrcc}
      1st arg: &   & $a_{1}$ & $a_{0}$ \\
      2nd arg: & + & $b_{1}$ & $b_{0}$ \\
    \hline
      carry:   &   &         & $c_0$ \\
      sum:     & = & $s_{1}$ & $s_0$
    \end{tabular}
    \hspace{10pt}~$\leadsto$\hspace{10pt}%
    \begin{minipage}{50pt}%
      \begin{flalign*}
        s_0 &= \boolf{XOR}(a_0, b_0) &\\
        c_0 &= a_0 \land b_0 &\\
        s_1 &= \boolf{XOR}(a_0, b_0, c_0) &
      \end{flalign*}
    \end{minipage}
  \end{center}
  \caption{Modelling 2bit addition (left) as Boolean function (right)}
  \label{fig:intro-2bit-addition}
\end{figure}


\section{The DIMACS de-facto standard}
\label{sec:sat-dimacs}
%
\index{Conjunction}
\index{Disjunction}
\index{Literal}
\index{Positive literal}
\index{Negative literal}
\index{Conjunctive Normal Form}
\begin{defi}
  A \emph{conjunction} is a sequence of Boolean functions combined using
  a logical OR. A \emph{disjunction} is a sequence of Boolean functions
  combined using a logical AND. A \emph{literal} is a Boolean variable
  (\emph{positive}) or its negation (\emph{negative}).

  A SAT problem is given in \emph{Conjunctive Normal Form} (CNF) if
  the problem is defined as conjunction of disjunctions of literals.
\end{defi}

A simple example for a SAT problem in CNF is the exclusive OR (XOR).
It takes two Boolean values $a$ and $b$ as arguments and returns true
if and only if the two arguments differ.
{
\setlength{\abovedisplayskip}{5pt}
\setlength{\belowdisplayskip}{5pt}
\setlength{\abovedisplayshortskip}{0pt}
\setlength{\belowdisplayshortskip}{0pt}
\begin{align} (a \lor b) \land (\neg a \lor \neg b) \label{eq:xor}\end{align}
}
Display~\ref{eq:xor} shows one conjunction (denoted $\land$) of two disjunctions
(denoted $\lor$) of literals (denoted $a$ and $b$ where prefix $\neg$ represents
negation). This structure constitutes a CNF.

\index{Disjunctive Normal Form}
Analogously we define a \emph{Disjunctive Normal Form} (DNF) as disjunction
of conjunctions of literals. The negation of a CNF is in DNF, because literals
are negated and conjunctions become disjunctions, vice versa.

\begin{theorem}
  \label{thm:all-cnf}
  Every Boolean function can be represented as CNF.
\end{theorem}

Theorem~\ref{thm:all-cnf} is easy to prove.
% Consider null-ary functions as
% induction base. A (null-ary) Boolean function is a set of associations.
% An association maps an assignment for input arguments to one output value.
% True can be represented as $a \lor \neg a$ and false can be
% represented as $a \land \neg a$ for some free Boolean variable $a$ and using
% only negation, conjunctions and disjunctions. Recognize that those representations
% are given in DNF as well as CNF. Hence all null-ary Boolean functions can be
% represented as CNF and DNF.
%
% Let $f$ be a Boolean function represented in DNF with $k$ input arguments.
% Extend every conjunction with a Boolean variable $v_{k+1}$.
Consider the truth table of an arbitrary Boolean function $f$ with $k$ input arguments
and $j$ rows of output value false. We represent $f$ as CNF.

Consider Boolean variables $b_{i,l}$ with $0 \leq i \leq j$ and $0 \leq l \leq k$.
For every row $i$ of the truth table with assignment $(r_i)$, add one disjunction to the CNF.
This disjunction contains $b_{i,l}$ if $r_{i,l}$ is false.
The disjunction contains $b_{i,l}$ if $r_{i,l}$ is true.

As far as $f$ is an arbitrary $k$-ary Boolean function, we have proven that
any function can be represented as CNF.

SAT problems are usually represented in the DIMACS de-facto standard.
Consider a SAT problem in CNF with \emph{nbclauses} clauses and
enumerate all variables from 1 to \emph{nbvars}. A DIMACS file is an ASCII text
file. Lines starting with \enquote{\texttt{c}} are skipped (comment lines).
The first remaining line has to begin with \enquote{\texttt{p cnf}} followed by
\emph{nbclauses} and \emph{nbvars} separated by spaces (header line).
All following non-comment lines are space-separated indices of Boolean variables
optionally prefixed by a minus symbol. Then one line represents one clause and
must be terminated with a zero symbol after a space. All lines are conjuncted
to form a CNF.

Variations of the DIMACS de-facto standard also allow multiline clauses (the
zero symbol constitutes the end of a clause) or arbitrary whitespace instead of
spaces. The syntactical details are individually published on a per competition
basis.

\renewcommand{\lstlistingname}{Listing}  % TODO otherwise it's Japanese, WTF
\begin{lstlisting}[caption={Display~\ref{eq:xor} represented in DIMACS format}]
p cnf 2 2
a b
-a -b
\end{lstlisting}

\index{Clause}
\index{$k$-clause}
\index{Unit clause}
\index{Horn clause}
\index{Definite clause}
\begin{defi}
  A \emph{clause} is a disjunction of literals.
  A $k$-\emph{clause} is a clause consisting of exactly $k$ literals.
  A \emph{unit clause} is a $1$-clause.
  A \emph{Horn clause} is a clause with at most one positive literal.
  A \emph{definite clause} is a clause with exactly one positive literal.
\end{defi}

\section{SAT features and CNF analysis}
\label{sec:sat-features}
%
At the very beginning I was very intrigued with the question
\enquote{What is an \enquote{average} SAT problem?}. Answers to this
question can help to optimize SAT solver memory layouts.
But originally I was wondering whether our differential cryptanalysis
SAT problems distinguish from \enquote{average} SAT problems in some
very basic properties. \\
First of all, we need to elaborate on the question itself.

\index{SAT feature}
\index{Feature value}
\begin{defi}[SAT feature]
  A \emph{SAT feature} is a statistical value (named \emph{feature value})
  retrievable from some given SAT problem in some well-defined encoding.

  A SAT feature is called \emph{performance-driven} if the runtime of any
  computation contributes to the feature value.
\end{defi}

The most basic example of a SAT feature is the number of variables and clauses
of a given SAT problem. This SAT feature is stored in the CNF header of a SAT
problem encoded in the DIMACS format.

It should be computationally easy to evaluate SAT features of a given SAT problem.
The general goal is to write a tool which evaluates several SAT features at the same
time and retrieve them for comparison with other problems. A SAT feature
is expected to be computable in linear time and memory with the number of variables
and number of clauses. But a suggested limit is only given with polynomial complexity
for evaluation algorithms. Sticking to this convention implies that evaluation
of satisfiability must not be necessary to evaluate a SAT feature under the
assumption that \cPneqNP. Hence the number of valid models cannot be a SAT feature
as far as satisfiability needs to be determined. But no actual hard boundary for
runtime requirements is given. Previous work has shown that expensive algorithms
can provide useful data in a small time frame if they are limited to a constant
subproblem size.

The most similar resource I found looking at SAT features was the
SATzilla project~\cite{satzilla2004,satzilla2008} in 2012. The authors systematically defined
138 SAT~features categorized in 12 groups. The features themselves are not
defined formally, but an implementation is provided bundled with example data.

\begin{table}[!h]
  \begin{center}
    \begin{tabular}{rl}
      \small{POSNEG\_RATIO\_CLAUSE\_mean} & ratio of positive to negative clauses, mean
    \end{tabular}
  \end{center}
\end{table}

Many SAT solvers collect feature values to improve algorithm selection,
restart strategies and estimate problem sizes. Recent trends to apply Machine
Learning to SAT solving imply feature evaluation. SAT features and the resulting
satisfiability runtime are used as training data for Machine Learning. One example
using SAT features for algorithm selection is ASlib~\cite{aslib}.

However, most of these SAT features are performance-driven.
Examples for performance-driven SAT features include the number of
restarts within a certain time frame or evaluation of local minima.



POSNEG-RATIO-CLAUSE-mean

In the following section we want to evaluate SAT features and
compare test cases.

\section{SAT features in comparison}

\begin{prop}
  The set of public benchmarks in SAT competitions between 2008 and 2015
  represent average SAT problems
\end{prop}

Define a large set of SAT features.
Present data.
Categorize data.

%\newcommand\satf{\begingroup\catcode`_=12\xxx}
%\newcommand\xxx[1]{\texttt{#1}\endgroup}
\newcommand{\satf}{\begingroup \catcode`_=12 \dosatf}
\newcommand{\dosatf}[1]{\texttt{#1}\endgroup}
\newcommand\sath[1]{\hline \multicolumn{2}{|c|}{#1} \\ \hline}
\begin{table}[!ht]
  \begin{tabular}{rl}
    \sath{Given a set of clauses, return a subset of clauses satisfying given criterion}
    \satf{clauses_allLitsNeg}     & all literals are negative \\
    \satf{clauses_oneLitNeg}      & exactly one literal is negative \\
    \satf{clauses_geqOneLitNeg}   & more than one literal is negative \\
    \satf{clauses_allLitsPos}     & all literals are positive \\
    \satf{clauses_oneLitPos}      & exactly one literal is positive \\
    \satf{clauses_geqOneLitPos}   & more than one literal is positive \\
    \satf{clauses_length1}        & clause contains exactly one literal (\enquote{unit clause}) \\
    \satf{clauses_length2}        & clause contains exactly two literals \\
    \satf{clauses_unique}         & clause did not yet occur \\
    \satf{clauses_tautological}   & clause contains some literal and its negation \\
    \sath{Given a set of literals/variables, return Boolean property}
    \satf{literals_existential}   & literal does not occur negated \\
    \satf{literals_unit}          & literal occurs in clause of length 1 \\
    \satf{literals_contradiction} & literal occurs with its negation on one clause \\
    \satf{literals_1occ}          & literal occurs only in one clause once \\
    \satf{literals_2occs}         & literal occurs two times in clauses \\
    \satf{literals_3occs}         & literal occurs three times in clauses \\
    \satf{variables_unit}         & variable occurs in clause of length 1 \\
    \sath{Given a set of clauses, return real number based on this clause}
    \satf{clauses_mapLength}      & number of literals in clause \\
    \satf{clauses_mapRatioPosNeg} & number of positive literals divided by total number of literal \\
    \satf{clauses_mapNumPos}      & number of positive literals in clause \\
    \sath{Given one clause, return Boolean property}
    \satf{clauselits_someEx}      & any is literal existential \\
    \satf{clauselits_allEx}       & all literals are existential \\
    \satf{clauselits_someUnit}    & contains unit variable \\
    \satf{clauselits_someContra}  & contains contradiction variable \\
    \satf{clauselits_all1occ}     & all variables occur only once in all clauses \\
    \satf{clauselits_all12occ}    & all variables occur only once or twice in all clauses \\
    \sath{Given all clauses, return the following property} \\
    \satf{concomp_variable}       & number of connected components where \\
                                  & two variables are in the same component \\
                                  & iff they occur in at least one clause together \\
    \satf{concomp_literal}        & number of connected components where \\
                                  & two literals are in the same component \\
                                  & iff they occur in at least one clause together \\
    \satf{xor2_count}             & Number of clause pairs ($a \lor b$, $\neg a \lor b$) \\
                                  & for two variables $a$ and $b$ \\
  \end{tabular}
\end{table}


\section{Basic SAT solving techniques}
\section{SAT solvers in use}
\section{Encodings}
\subsection{STP approach}
